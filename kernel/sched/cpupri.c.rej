--- kernel/sched/cpupri.c
+++ kernel/sched/cpupri.c
@@ -27,12 +27,12 @@
  *  of the License.
  */
 
-#include "sched.h"
-
 #include <linux/gfp.h>
 #include <linux/sched.h>
 #include <linux/sched/rt.h>
+#include <linux/slab.h>
 #include "cpupri.h"
+#include "sched.h"
 
 /* Convert between a 140 based task->prio, and our 102 based cpupri */
 static int convert_prio(int prio)
@@ -51,24 +51,6 @@ static int convert_prio(int prio)
 	return cpupri;
 }
 
-/**
- * cpupri_find - remove a cpu from the mask if it is likely non-preemptible
- * @lowest_mask: mask with selected CPUs (non-NULL)
- */
-static void
-drop_nopreempt_cpus(struct cpumask *lowest_mask)
-{
-	unsigned cpu = cpumask_first(lowest_mask);
-	while (cpu < nr_cpu_ids) {
-		/* unlocked access */
-		struct task_struct *task = ACCESS_ONCE(cpu_rq(cpu)->curr);
-		if (task_may_not_preempt(task, cpu)) {
-			cpumask_clear_cpu(cpu, lowest_mask);
-		}
-		cpu = cpumask_next(cpu, lowest_mask);
-	}
-}
-
 /**
  * cpupri_find - find the best (lowest-pri) CPU in the system
  * @cp: The cpupri context
@@ -82,18 +64,16 @@ drop_nopreempt_cpus(struct cpumask *lowest_mask)
  * any discrepancies created by racing against the uncertainty of the current
  * priority configuration.
  *
- * Returns: (int)bool - CPUs were found
+ * Return: (int)bool - CPUs were found
  */
 int cpupri_find(struct cpupri *cp, struct task_struct *p,
 		struct cpumask *lowest_mask)
 {
 	int idx = 0;
 	int task_pri = convert_prio(p->prio);
-	bool drop_nopreempts = task_pri <= MAX_RT_PRIO;
 
 	BUG_ON(task_pri >= CPUPRI_NR_PRIORITIES);
 
-retry:
 	for (idx = 0; idx < task_pri; idx++) {
 		struct cpupri_vec *vec  = &cp->pri_to_cpu[idx];
 		int skip = 0;
@@ -224,7 +195,7 @@ void cpupri_set(struct cpupri *cp, int cpu, int newpri)
  * cpupri_init - initialize the cpupri structure
  * @cp: The cpupri context
  *
- * Returns: -ENOMEM if memory fails.
+ * Return: -ENOMEM on memory allocation failure.
  */
 int cpupri_init(struct cpupri *cp)
 {
@@ -240,8 +211,13 @@ int cpupri_init(struct cpupri *cp)
 			goto cleanup;
 	}
 
+	cp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);
+	if (!cp->cpu_to_pri)
+		goto cleanup;
+
 	for_each_possible_cpu(i)
 		cp->cpu_to_pri[i] = CPUPRI_INVALID;
+
 	return 0;
 
 cleanup:
@@ -258,14 +234,10 @@ void cpupri_cleanup(struct cpupri *cp)
 {
 	int i;
 
+	kfree(cp->cpu_to_pri);
 	for (i = 0; i < CPUPRI_NR_PRIORITIES; i++)
 		free_cpumask_var(cp->pri_to_cpu[i].mask);
 }
-
-/*
- * cpupri_check_rt - check if CPU has a RT task
- * should be called from rcu-sched read section.
- */
 bool cpupri_check_rt(void)
 {
 	int cpu = raw_smp_processor_id();
