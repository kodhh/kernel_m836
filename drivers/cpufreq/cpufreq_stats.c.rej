--- drivers/cpufreq/cpufreq_stats.c
+++ drivers/cpufreq/cpufreq_stats.c
@@ -9,25 +9,45 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/atomic.h>
 #include <linux/cpu.h>
 #include <linux/cpufreq.h>
+#include <linux/hashtable.h>
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/sort.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/proc_fs.h>
+#include <linux/profile.h>
 #include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
 #include <asm/cputime.h>
 
+#define UID_HASH_BITS 10
+
+DECLARE_HASHTABLE(uid_hash_table, UID_HASH_BITS);
+
 static spinlock_t cpufreq_stats_lock;
 
+static DEFINE_RT_MUTEX(uid_lock); /* uid_hash_table */
+
+struct uid_entry {
+ 	uid_t uid;
+ 	unsigned int dead_max_states;
+ 	unsigned int alive_max_states;
+ 	u64 *dead_time_in_state;
+ 	u64 *alive_time_in_state;
+ 	struct hlist_node hash;
+};
 struct cpufreq_stats {
 	unsigned int cpu;
 	unsigned int total_trans;
 	unsigned long long last_time;
 	unsigned int max_state;
 	unsigned int state_num;
-	unsigned int last_index;
+	atomic_t cpu_freq_i;
+ 	atomic_t all_freq_i;
 	u64 *time_in_state;
 	unsigned int *freq_table;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
@@ -53,6 +73,7 @@ struct all_freq_table {
 };
 
 static struct all_freq_table *all_freq_table;
+static bool cpufreq_all_freq_init;
 
 static DEFINE_PER_CPU(struct all_cpufreq_stats *, all_cpufreq_stats);
 static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
@@ -197,17 +337,66 @@ static int cpufreq_stats_update(unsigned int cpu)
 		return 0;
 	}
 	if (stat->time_in_state) {
-		stat->time_in_state[stat->last_index] +=
-			cur_time - stat->last_time;
+		int cpu_freq_i = atomic_read(&stat->cpu_freq_i);
+
+ 		stat->time_in_state[cpu_freq_i] += cur_time - stat->last_time;
 		if (all_stat)
-			all_stat->time_in_state[stat->last_index] +=
-					cur_time - stat->last_time;
+			all_stat->time_in_state[cpu_freq_i] +=
+ 				cur_time - stat->last_time;
 	}
 	stat->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 }
 
+void cpufreq_task_stats_init(struct task_struct *p)
+{
+ 	size_t alloc_size;
+
+ 	WRITE_ONCE(p->time_in_state, NULL);
+ 	WRITE_ONCE(p->max_states, 0);
+
+ 	if (!all_freq_table || !cpufreq_all_freq_init)
+ 		return;
+
+ 	WRITE_ONCE(p->max_states, all_freq_table->table_size);
+
+ 	/* Create all_freq_table for clockticks in all possible freqs in all
+ 	 * cpus
+ 	 */
+ 	alloc_size = p->max_states * sizeof(p->time_in_state[0]);
+
+ 	WRITE_ONCE(p->time_in_state, kzalloc(alloc_size, GFP_KERNEL));
+}
+
+void cpufreq_task_stats_exit(struct task_struct *p)
+{
+ 	void *temp = p->time_in_state;
+
+ 	WRITE_ONCE(p->time_in_state, NULL);
+ 	mb(); /* p->time_in_state */
+ 	kfree(temp);
+}
+
+int proc_time_in_state_show(struct seq_file *m, struct pid_namespace *ns,
+ 			    struct pid *pid, struct task_struct *p)
+{
+ 	int i;
+
+ 	if (!all_freq_table || !cpufreq_all_freq_init || !p->time_in_state)
+ 		return 0;
+
+ 	spin_lock(&cpufreq_stats_lock);
+ 	for (i = 0; i < p->max_states; ++i) {
+ 		seq_printf(m, "%d %lu\n", all_freq_table->freq_table[i],
+ 			(unsigned long)cputime_to_clock_t(
+ 				atomic_read(&p->time_in_state[i])));
+ 	}
+ 	spin_unlock(&cpufreq_stats_lock);
+
+ 	return 0;
+}
+
 static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
@@ -246,21 +435,48 @@ static int get_index_all_cpufreq_stat(struct all_cpufreq_stats *all_stat,
 	return -1;
 }
 
-void acct_update_power(struct task_struct *task, cputime_t cputime)
+/* Called without cpufreq_stats_lock held */
+void acct_update_power(struct task_struct *task, cputime_t cputime) {
 {
 	struct cpufreq_power_stats *powerstats;
 	struct cpufreq_stats *stats;
 	unsigned int cpu_num, curr;
+        int cpu_freq_i;
+ 	int all_freq_i;
+ 	u64 last_cputime;
+ 	atomic64_t *time_in_state;
 
 	if (!task)
 		return;
 	cpu_num = task_cpu(task);
-	powerstats = per_cpu(cpufreq_power_stats, cpu_num);
 	stats = per_cpu(cpufreq_stats_table, cpu_num);
-	if (!powerstats || !stats)
+	if (!stats)
+ 		return;
+
+ 	all_freq_i = atomic_read(&stats->all_freq_i);
+ 	time_in_state = READ_ONCE(task->time_in_state);
+
+ 	/* This function is called from a different context
+ 	 * Interruptions in between reads/assignements are ok
+ 	 */
+ 	if (all_freq_table && cpufreq_all_freq_init && time_in_state &&
+ 		!(task->flags & PF_EXITING) &&
+ 		all_freq_i != -1 && all_freq_i < READ_ONCE(task->max_states)) {
+ 		last_cputime =
+ 			atomic_read(&time_in_state[all_freq_i]);
+ 		atomic_set(&time_in_state[all_freq_i],
+ 			last_cputime + cputime);
+ 	}
+
+ 	powerstats = per_cpu(cpufreq_power_stats, cpu_num);
+ 	if (!powerstats)
+ 		return;
+
+ 	cpu_freq_i = atomic_read(&stats->cpu_freq_i);
+ 	if (cpu_freq_i == -1)
 		return;
 
-	curr = powerstats->curr[stats->last_index];
+	curr = powerstats->curr[cpu_freq_i];
 	if (task->cpu_power != ULLONG_MAX)
 		task->cpu_power += curr * cputime_to_usecs(cputime);
 }
@@ -313,7 +529,7 @@ static ssize_t show_all_time_in_state(struct kobject *kobj,
 			index = get_index_all_cpufreq_stat(all_stat, freq);
 			if (index != -1) {
 				len += scnprintf(buf + len, PAGE_SIZE - len,
-					"%llu\t\t", (unsigned long long)
+					"%lu\t\t", (unsigned long)
 					cputime64_to_clock_t(all_stat->time_in_state[index]));
 			} else {
 				len += scnprintf(buf + len, PAGE_SIZE - len,
@@ -528,7 +744,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->state_num = j;
 	spin_lock(&cpufreq_stats_lock);
 	stat->last_time = get_jiffies_64();
-	stat->last_index = freq_table_get_index(stat, policy->cur);
+	atomic_set(&stat->cpu_freq_i, freq_table_get_index(stat, policy->cur));
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 error_alloc:
@@ -645,7 +861,8 @@ static void free_all_freq_table(void)
 static void add_all_freq_table(unsigned int freq)
 {
 	unsigned int size;
-	size = sizeof(unsigned int) * (all_freq_table->table_size + 1);
+	size = sizeof(all_freq_table->freq_table[0]) *
+ 		(all_freq_table->table_size + 1);
 	all_freq_table->freq_table = krealloc(all_freq_table->freq_table,
 			size, GFP_ATOMIC);
 	if (IS_ERR(all_freq_table->freq_table)) {
@@ -778,9 +995,11 @@ static void cpufreq_stats_create_table(unsigned int cpu)
 static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
+        int i;
 	struct cpufreq_freqs *freq = data;
 	struct cpufreq_stats *stat;
-	int old_index, new_index;
+	int cpu_freq_old_i, cpu_freq_new_i;
+ 	int all_freq_old_i, all_freq_new_i;
 
 	if (val != CPUFREQ_POSTCHANGE)
 		return 0;
@@ -789,28 +1008,101 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	if (!stat)
 		return 0;
 
-	old_index = stat->last_index;
-	new_index = freq_table_get_index(stat, freq->new);
+	cpu_freq_old_i = atomic_read(&stat->cpu_freq_i);
+ 	cpu_freq_new_i = freq_table_get_index(stat, freq->new);
+
+ 	all_freq_old_i = atomic_read(&stat->all_freq_i);
+ 	for (i = 0; i < all_freq_table->table_size; ++i) {
+ 		if (all_freq_table->freq_table[i] == freq->new)
+ 			break;
+ 	}
+ 	if (i != all_freq_table->table_size)
+ 		all_freq_new_i = i;
+ 	else
+ 		all_freq_new_i = -1;
 
 	/* We can't do stat->time_in_state[-1]= .. */
-	if (old_index == -1 || new_index == -1)
+	if (cpu_freq_old_i == -1 || cpu_freq_new_i == -1)
+ 		return 0;
+
+ 	if (all_freq_old_i == -1 || all_freq_new_i == -1)
 		return 0;
 
 	cpufreq_stats_update(freq->cpu);
 
-	if (old_index == new_index)
+	if (cpu_freq_old_i == cpu_freq_new_i)
+ 		return 0;
+
+ 	if (all_freq_old_i == all_freq_new_i)
 		return 0;
 
 	spin_lock(&cpufreq_stats_lock);
-	stat->last_index = new_index;
+	atomic_set(&stat->cpu_freq_i, cpu_freq_new_i);
+ 	atomic_set(&stat->all_freq_i, all_freq_new_i);
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
-	stat->trans_table[old_index * stat->max_state + new_index]++;
+	stat->trans_table[cpu_freq_old_i * stat->max_state + cpu_freq_new_i]++;
 #endif
 	stat->total_trans++;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 }
 
+static int process_notifier(struct notifier_block *self,
+ 			unsigned long cmd, void *v)
+{
+ 	struct task_struct *task = v;
+ 	struct uid_entry *uid_entry;
+ 	uid_t uid;
+ 	int i;
+
+ 	if (!task)
+ 		return NOTIFY_OK;
+
+ 	rt_mutex_lock(&uid_lock);
+
+ 	uid = from_kuid_munged(current_user_ns(), task_uid(task));
+ 	uid_entry = find_or_register_uid(uid);
+ 	if (!uid_entry) {
+ 		rt_mutex_unlock(&uid_lock);
+ 		pr_err("%s: failed to find uid %d\n", __func__, uid);
+ 		return NOTIFY_OK;
+ 	}
+
+ 	if (uid_entry->dead_max_states < task->max_states) {
+ 		uid_entry->dead_time_in_state = krealloc(
+ 			uid_entry->dead_time_in_state,
+ 			task->max_states *
+ 			sizeof(uid_entry->dead_time_in_state[0]),
+ 			GFP_ATOMIC);
+ 		memset(uid_entry->dead_time_in_state +
+ 			uid_entry->dead_max_states,
+ 			0, (task->max_states - uid_entry->dead_max_states) *
+ 			sizeof(uid_entry->dead_time_in_state[0]));
+ 		uid_entry->dead_max_states = task->max_states;
+ 	}
+
+ 	for (i = 0; i < task->max_states; ++i) {
+ 		uid_entry->dead_time_in_state[i] +=
+ 			atomic_read(&task->time_in_state[i]);
+ 	}
+
+ 	rt_mutex_unlock(&uid_lock);
+ 	return NOTIFY_OK;
+}
+
+static int uid_time_in_state_open(struct inode *inode, struct file *file)
+{
+ 	return single_open(file, uid_time_in_state_show, PDE_DATA(inode));
+}
+
+static const struct file_operations uid_time_in_state_fops = {
+ 	.open		= uid_time_in_state_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= single_release,
+};
+
+
 static struct notifier_block notifier_policy_block = {
 	.notifier_call = cpufreq_stat_notifier_policy
 };
@@ -839,6 +1135,13 @@ static int __init cpufreq_stats_init(void)
 	for_each_online_cpu(cpu)
 		cpufreq_stats_create_table(cpu);
 
+        /* XXX TODO task support for time_in_state doesn't update freq
+ 	 * info for tasks already initialized, so tasks initialized early
+ 	 * (before cpufreq_stat_init is done) do not get time_in_state data
+ 	 * and CPUFREQ_TRANSITION_NOTIFIER does not update freq info for
+ 	 * tasks already created
+ 	 */
+
 	ret = cpufreq_register_notifier(&notifier_trans_block,
 				CPUFREQ_TRANSITION_NOTIFIER);
 	if (ret) {
@@ -858,6 +1161,14 @@ static int __init cpufreq_stats_init(void)
 	if (ret)
 		pr_warn("Cannot create sysfs file for cpufreq current stats\n");
 
+        proc_create_data("uid_time_in_state", 0444, NULL,
+ 		&uid_time_in_state_fops, NULL);
+
+ 	profile_event_register(PROFILE_TASK_EXIT, &process_notifier_block);
+
+ 	cpufreq_all_freq_init = true;
+
+
 	return 0;
 }
 static void __exit cpufreq_stats_exit(void)
